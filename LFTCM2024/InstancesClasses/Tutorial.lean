import LFTCM2024.Common

open BigOperators Finset Real
noncomputable section
set_option linter.unusedVariables false
set_option autoImplicit false


/- # Instances and Classes -/

/-
## Structures

Learning about structures is the next step towards doing sophisticated mathematics.

Structures are used to build data and properties together.
For example in the structure below `Point` bundles three coordinates together.
-/

@[ext]
structure Point where
  x : ‚Ñù
  y : ‚Ñù
  z : ‚Ñù

#check Point

section

/- Given a point, we get access to its coordinates / projections. -/
variable (a : Point)
#check Point.x a
#check a.x
#check a.y
#check a.z

end





/- We can prove that two points are equal using the `ext` tactic. -/

example (a b : Point) (hx : a.x = b.x) (hy : a.y = b.y) (hz : a.z = b.z) :
    a = b := by
  ext
  all_goals assumption

example (a b : Point) (hx : a.x = b.x) (hy : a.y = b.y) (hz : a.z = b.z) :
  a = b := by ext <;> assumption


/- There are multiple ways to define a point (or more generally an instance of a structure).

Tip: if you write `_` for a Point, a lightbulb üí° will appear.
Clicking it will give you the skeleton -/

def myPoint1 : Point where
  x := 1
  y := 2
  z := 3

def myPoint2 :=
  { x := 1, y := 2, z := 3 : Point }

def myPoint3 : Point :=
  { x := 1
    y := 2
    z := 3 }

def myPoint4 : Point := ‚ü®1, 2, 3‚ü©

def myPoint5 := Point.mk 1 2 3



namespace Point

/- We can define operations on points, like addition. -/

def add (a b : Point) : Point :=
  ‚ü®a.x + b.x, a.y + b.y, a.z + b.z‚ü©

def add' : Point ‚Üí Point ‚Üí Point :=
  fun ‚ü®ux, uy, uz‚ü© ‚ü®vx, vy, vz‚ü© ‚Ü¶ ‚ü®ux + vx, uy + vy, uz + vz‚ü©

/- We define these operations in `namespace Point`. This means that if this namespace is open
we can write `add p q`, but if the namespace isn't open, we have to write `Point.add p q`.
In either case, we can use the *projection notation*, `p.add q` where `p q : Point`.
Lean knows that we mean the function `Point.add`, since the type of `p` is `Point`. -/

#check add myPoint1 myPoint2
#check myPoint1.add myPoint2

end Point

#check Point.add myPoint1 myPoint2
#check myPoint1.add myPoint2

open Point

#check add myPoint1 myPoint2


namespace Point

/- We can prove properties about points. `protected` in the line below means that
even in the namespace `Point` we still have to write `Point.add_commutative` -/

protected lemma add_commutative (a b : Point) : add a b = add b a := by simp [add, add_comm]

#check Point.add_commutative

/- We can also state that we want to use the `+` notation here.
In that case, we have to write lemmas stating how `+` computes. -/

instance : Add Point := ‚ü®add‚ü©

@[simp] lemma add_x (a b : Point) : (a + b).x = a.x + b.x := by rfl
@[simp] lemma add_y (a b : Point) : (a + b).y = a.y + b.y := by rfl
@[simp] lemma add_z (a b : Point) : (a + b).z = a.z + b.z := by rfl

example (a b : Point) : a + b = b + a := by ext <;> simp [add_comm]

end Point





/- We can bundle properties in structures -/

structure PosPoint where
  x : ‚Ñù
  y : ‚Ñù
  z : ‚Ñù
  x_pos : 0 < x
  y_pos : 0 < y
  z_pos : 0 < z

def PointPoint.add (a b : PosPoint) : PosPoint :=
{ x := a.x + b.x
  y := a.y + b.y
  z := a.z + b.z
  x_pos := by linarith [a.x_pos, b.x_pos]
  y_pos := by linarith [a.y_pos, b.y_pos]
  z_pos := by linarith [a.z_pos, b.z_pos] }

/- Going from `Point` to `PosPoint` has code duplication.
We don't want this when defining monoids, groups, rings, fields. -/

structure PosPoint' extends Point where
  x_pos : 0 < x
  y_pos : 0 < y
  z_pos : 0 < z

def PointPoint'.add (a b : PosPoint') : PosPoint' :=
{ a.toPoint + b.toPoint with
  x_pos := by dsimp; linarith [a.x_pos, b.x_pos]
  y_pos := by dsimp; linarith [a.y_pos, b.y_pos]
  z_pos := by dsimp; linarith [a.z_pos, b.z_pos] }

/- We could also define a type like this using a subtype. The notation is `{x : Œ± // p x}`
(not to be confused with the notation `{x : Œ± | p x}` to define a set). -/

def PosReal : Type :=
  { x : ‚Ñù // x > 0 }

/- Elements here are pairs of
  (1) a real number
  (2) a proof that this real number is postive. -/

example (x : ‚Ñù) (hx : x > 0) : PosReal := ‚ü®x, hx‚ü©

example (x : PosReal) : x.1 > 0 := x.2






/- Structures can have parameters -/

@[ext] structure Triple (Œ± : Type*) where
  x : Œ±
  y : Œ±
  z : Œ±

#check Triple.mk 1 2 3

#check Triple.mk sin cos tan




/- # Abelian groups

Let's define abelian groups.
We say that a type `G` has the structure of an abelian group
if there are `add`, `zero`, `neg`, with some axioms.

We write it as a *class*, and for specific abelian groups we write
*instance* instead of *def*.
-/

class AbelianGroup (G : Type*) where
  add (x : G) (y : G) : G
  zero : G
  neg (x : G) : G
  comm (x y : G) : add x y = add y x
  assoc (x y z : G) : add (add x y) z = add x (add y z)
  add_zero : ‚àÄ x : G, add x zero = x
  add_neg : ‚àÄ x : G, add x (neg x) = zero


def MyIntegers := ‚Ñ§

/-
example (x y : MyIntegers) : MyIntegers := x + y -- error
-/

instance IntGroup : AbelianGroup MyIntegers := by
  unfold MyIntegers
  exact
  { add := fun a b ‚Ü¶ a + b
    comm := add_comm
    assoc := add_assoc
    zero := 0
    add_zero := by simp
    neg := fun a ‚Ü¶ -a
    add_neg := by simp }


/-
Using `class` + `instance` tells Lean to make a database of abelian groups.
If you write a lemma with argument `[AbelianGroup G]`
("instance-implicit arguments"),
When applying such a lemma, Lean will search
through in this database to fill this argument.
-/

/- The following lines say that we want to use the
notation `+`, `0`, and `-` for abelian groups. -/
instance {G : Type*} [AbelianGroup G] : Add G := ‚ü®AbelianGroup.add‚ü©
instance {G : Type*} [AbelianGroup G] : Zero G := ‚ü®AbelianGroup.zero‚ü©
instance {G : Type*} [AbelianGroup G] : Neg G := ‚ü®AbelianGroup.neg‚ü©

lemma my_add_comm {G : Type*} [AbelianGroup G] (x y : G) :
    x + y = y + x := AbelianGroup.comm x y
lemma my_add_assoc {G : Type*} [AbelianGroup G] (x y z : G) :
    (x + y) + z = x + (y + z) := AbelianGroup.assoc x y z
lemma my_add_zero {G : Type*} [AbelianGroup G] (x : G) :
    x + 0 = x := AbelianGroup.add_zero x
lemma my_add_neg {G : Type*} [AbelianGroup G] (x : G) :
    x + -x = 0 := AbelianGroup.add_neg x

lemma zero_unique {G : Type*} [AbelianGroup G] {z : G}
    (h : ‚àÄ x, z + x = x) : z = 0 := by
  rw [‚Üê my_add_zero z, h]

#check AbelianGroup.add

instance AbelianGroup.prod (G G' : Type*) [AbelianGroup G] [AbelianGroup G'] :
    AbelianGroup (G √ó G') where
  add := fun a b ‚Ü¶ (a.1 + b.1, a.2 + b.2)
  zero := (0, 0)
  neg := fun a ‚Ü¶ (- a.1, - a.2)
  comm := by intros; ext <;> exact?
  assoc := by intros; ext <;> exact?
  add_zero := by intros; ext <;> exact?
  add_neg := by intros; ext <;> exact?


variable (x y z : MyIntegers) in
#check (x, y) + (z, x)




/- In mathlib, there are two notions of abelian groups,
one written using `(*, 1, ‚Åª¬π)` and one using `(+, 0, -)`. -/

#check CommGroup
#check AddCommGroup


/- To explain this distinction, consider monoids (groups without inverses).
`(‚Ñù, +, 0)` and `(‚Ñù, *, 1)` are both monoids, and we want to have a distinction in notation and
lemma names of these two structures. -/

example : Monoid ‚Ñù := by infer_instance
example : AddMonoid ‚Ñù := by infer_instance
example (x : ‚Ñù) : x + 0 = x := add_zero x
example (x : ‚Ñù) : x * 1 = x := mul_one x

#check Monoid
#check AddMonoid







/- ## Exercises -/

/- 1. Define the structure of "strict bipointed types", i.e. a type together with 2 unequal points
`x‚ÇÄ ‚â† x‚ÇÅ` in it.
Then state and prove the lemma that for any object in this class we have `‚àÄ z, z ‚â† x‚ÇÄ ‚à® z ‚â† x‚ÇÅ.` -/



/- 2. Define scalar multiplication of a real number and a `Point`.
Also define scalar multiplication of a positive real number and a `PosPoint`. -/



/- 3. Define Pythagorean triples, i.e. triples `a b c : ‚Ñï` with `a^2 + b^2 = c^2`.
Give an example of a Pythagorean triple, and show that multiplying a Pythagorean triple by a
constant gives another Pythagorean triple. -/



/- 4. Prove that triples of equivalent types are equivalent.
`‚âÉ` is the type of equivalences / bijections between two types. -/

example (Œ± Œ≤ : Type*) (e : Œ± ‚âÉ Œ≤) : Triple Œ± ‚âÉ Triple Œ≤ := sorry


/- 5. Show that if `G` is an abelian group then triples from elements of `G` is an abelian group. -/

example (G : Type*) [AbelianGroup G] : AbelianGroup (Triple G) := sorry














/- ## Coercions

You can specify *coercions* to say that an element of one type can be silently coerced to an element
of another type. We've already seen the coercions
`‚Ñï ‚Üí ‚Ñ§ ‚Üí ‚Ñö ‚Üí ‚Ñù ‚Üí ‚ÑÇ`
for numbers.
-/

recall PosReal := {x : ‚Ñù // x > 0}

instance : Coe PosReal Real := ‚ü®fun x ‚Ü¶ x.1‚ü©

def diff (x y : PosReal) : ‚Ñù := x - y

#check fun (x : PosReal) ‚Ü¶ (x : ‚ÑÇ)




/-
* We use `CoeSort` to coerce to `Type _` (or `Sort _`)
* We use `CoeFun` to coerce to functions.
-/
structure PointedType where
  carrier : Type*
  pt : carrier

instance : CoeSort PointedType Type* := ‚ü®fun Œ± ‚Ü¶ Œ±.carrier‚ü©

structure PointedFunction (X Y : PointedType) where
  toFun : X ‚Üí Y
  toFun_pt : toFun X.pt = Y.pt

infix:50 " ‚Üí. " => PointedFunction

instance {X Y : PointedType} : CoeFun (X ‚Üí. Y) (fun _ ‚Ü¶ X ‚Üí Y) := ‚ü®fun e ‚Ü¶ e.toFun‚ü©

-- these two are hints to the pretty printer to print these operations a bit nicer.
attribute [pp_dot] PointedType.pt
attribute [coe] PointedFunction.toFun

namespace PointedFunction

variable {X Y Z : PointedType}

@[simp] lemma coe_pt (f : X ‚Üí. Y) : f X.pt = Y.pt := f.toFun_pt

lemma comp (g : Y ‚Üí. Z) (f : X ‚Üí. Y) : X ‚Üí. Z :=
{ toFun := g ‚àò f
  toFun_pt := by sorry }

end PointedFunction
